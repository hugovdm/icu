Index: source/tools/genrb/reslist.c
===================================================================
--- source/tools/genrb/reslist.c	(revision 25919)
+++ source/tools/genrb/reslist.c	(working copy)
@@ -27,6 +27,316 @@
 
 static UBool gIncludeCopyright = FALSE;
 
+static void printCounters(const struct SRBRoot *bundle, const char *bundleName, uint32_t bundleSize) {
+    /* file,size,#strings,str.size,save,#mini,mini.save,incompressible,comp.pad */
+    printf("potential: %s,%lu,%ld,%ld,%ld,%ld,%ld,%ld,%ld\n",
+           bundleName, (long)bundleSize,
+           (long)bundle->fStringsCount, (long)bundle->fStringsSize,
+           (long)(bundle->fStringsSize - bundle->fPotentialSize),
+           (long)bundle->f4ASCIICount, (long)bundle->f4ASCIIReduction,
+           (long)bundle->fIncompressibleStrings,
+           (long)bundle->fCompressedPadding);
+}
+
+/* not Han, not Hangul, not an unpaired surrogate? */
+static UBool isCompressible(UChar32 c) {
+    return
+        (c < LAST_WINDOW_LIMIT) &&
+        !(  (0x3400 <= c && c <= 0x9fff) ||
+            (0xac00 <= c && c <= 0xdfff) ||
+            (0x20000 <= c && c <= 0x3ffff));
+}
+
+/* 2-byte-encodable in CJK mode */
+static UBool is2ByteCJK(UChar32 c) {
+    return (0x3000 <= c && c <= 0x9fff) || (0xac00 <= c && c <= 0xd7ff);
+}
+
+static UBool isDirectASCII(UChar32 c) {
+    /* ASCII character with direct single-byte encoding */
+    if (c <= 0x7e) {
+        if (c >= 0x20 || (c == 9 || c == 0xa || c == 0xd)) {
+            return TRUE;
+        }
+    }
+    return FALSE;
+}
+
+static void
+addToStats(struct SRBRoot *bundle, const UChar *s, int32_t length) {
+    int32_t i, window;
+    UChar32 c;
+
+    for (i = 0; i < length;) {
+        U16_NEXT(s, i, length, c);
+        /* don't count ASCII in its window */
+        if (isCompressible(c) && !isDirectASCII(c)) {
+            window = c >> 7;
+            ++bundle->fWindowCounts[window];
+        }
+    }
+}
+
+static void
+findTopWindows(struct SRBRoot *bundle) {
+    int32_t topWindowCounts[3] = { 0, 0, 0 };
+    int32_t *windowCounts = bundle->fWindowCounts;
+    int32_t *windows = bundle->fWindows;
+    int32_t window, windowCount;
+    int32_t i, j, k;
+
+    for (window = 0, i = 0; i < (LAST_WINDOW_LIMIT >> 7); window += 0x80, ++i) {
+        windowCount = windowCounts[i];
+        if (windowCount > topWindowCounts[2]) {
+            for (j = 2; j > 0 && windowCount > topWindowCounts[j - 1]; --j) {}
+            /* insert window at index j */
+            for (k = 2; k > j; --k) {
+                windows[k] = windows[k - 1];
+                topWindowCounts[k] = topWindowCounts[k - 1];
+            }
+            windows[j] = window;
+            topWindowCounts[j] = windowCount;
+        }
+    }
+    printf("top windows: %04lx,%ld,%04lx,%ld,%04lx,%ld\n",
+           windows[0], topWindowCounts[0],
+           windows[1], topWindowCounts[1],
+           windows[2], topWindowCounts[2]);
+}
+
+static int32_t
+getWindow(const int32_t *windows, UChar32 c, int32_t *windowIndex) {
+    int32_t i;
+    for (i = 0; i <= 2; ++i) {
+        int32_t w = windows[i];
+        if (w <= c && c <= (w + 0x7f)) {
+            *windowIndex = i;
+            return w;
+        }
+    }
+    return -1;
+}
+
+static uint32_t
+encodeMiniString(const struct SRBRoot *bundle,
+                 const UChar *s, int32_t length) {
+    UChar32 chars[4];
+    const int32_t *windows = bundle->fWindows;
+    uint32_t result;
+    int32_t w;
+    int32_t i, count, windowIndex;
+    UChar32 c;
+
+    if (length > 6) {
+        return 0xffffffff;  /* too long */
+    }
+    if (length == 0) {
+        return 0;  /* empty string encoded as 0 */
+    }
+    /* try to encode 1..4 ASCII characters */
+    if (length <= 4) {
+        result = 0;
+        for (i = 0;;) {
+            if (isDirectASCII(c = s[i++])) {
+                result = (result << 7) | (uint32_t)c;
+            } else {
+                break;  /* does not fit */
+            }
+            if (i == length) {
+                /* bits 27..21 = 0/9/A/D/20..7E for 1..4 ASCII chars */
+                return result;
+            }
+        }
+    }
+    /* read code points */
+    chars[2] = 0;  /* TODO: keep only for "mini: www" debug output */
+    for (count = 0, i = 0; count < 3 && i < length;) {
+        U16_NEXT(s, i, length, c);
+        chars[count++] = c;
+    }
+    if (i < length) {
+        return 0xffffffff;  /* more than 3 characters, does not fit */
+    }
+    /* try to encode 2 or 3 window characters */
+    c = chars[0];
+    if (count >= 2 && (w = getWindow(windows, c, &windowIndex)) >= 0) {
+        for (result = 0, i = 1;; ++i) {
+            result = (result << 7) | (uint32_t)(c - w);
+            if (i == count) {
+                /* bits 27..21 = 2/4/6 from window 0/1/2, plus 1 if 3 chars */
+                result |= ((uint32_t)((windowIndex << 1) + count) << 21);
+                printf("mini: www[%d]w%d %08lx <%04lx %04lx %04lx>\n",
+                       (int)count, (int)windowIndex, (long)result,
+                       (long)chars[0], (long)chars[1], (long)chars[2]);
+                return result;
+            }
+            if (!(w <= (c = chars[i]) && c <= (w + 0x7f))) {
+                c = chars[0];  /* TODO: remove if we don't use c any more below */
+                break;  /* does not fit */
+            }
+        }
+    }
+    /* try to encode 1 character */
+    if (count == 1) {
+        /* bits 27..21 = 1 for 1 character */
+        result = ((uint32_t)1 << 21) | (uint32_t)c;
+        printf("mini: single %08lx\n", (long)result);
+        return result;
+    }
+    return 0xffffffff;  /* does not fit */
+}
+
+static UChar32
+nextChar(const UChar *s, int32_t i, int32_t length) {
+    if (i < length) {
+        UChar32 c;
+        U16_NEXT(s, i, length, c);
+        return c;
+    } else {
+        return U_SENTINEL;
+    }
+}
+
+static int32_t
+encodeSingleByteMode(const struct SRBRoot *bundle, int32_t window,
+                     const UChar *s, int32_t length) {
+    const int32_t *windows = bundle->fWindows;
+    int32_t w;
+    int32_t i, windowIndex, numBytes = 0;
+    UChar32 c;
+
+    for (i = 0; i < length;) {
+        U16_NEXT(s, i, length, c);
+        if (isDirectASCII(c)) {
+            /* 9/A/D/20..7E */
+            ++numBytes;
+            continue;
+        } else if (window <= c && c <= (window + 0x7f)) {
+            /* 80..FF */
+            ++numBytes;
+            continue;
+        }
+        w = getWindow(windows, c, &windowIndex);
+        if (w >= 0) {
+            /* windowIndex+xx */
+            UChar32 next = nextChar(s, i, length);  /* one-character lookahead */
+            if (w <= next && next <= (w + 0x7f)) {
+                window = w;  /* switch to this window */
+            }
+            numBytes += 2;
+            continue;
+        }
+        /* 0F..1F+xx+yy */
+        numBytes += 3;
+    }
+    return numBytes;
+}
+
+static int32_t
+encodeCJK(const struct SRBRoot *bundle, const UChar *s, int32_t length) {
+    int32_t i, numBytes = 0;
+    UChar32 c;
+
+    for (i = 0; i < length;) {
+        U16_NEXT(s, i, length, c);
+        if (is2ByteCJK(c)) {
+            /* write c as 2 bytes */
+            numBytes += 2;
+        } else if (c == 9 || c == 0xa || (0x20 <= c && c <= 0x7e)) {
+            ++numBytes;
+        } else if (c <= 0xffff || (0x20000 <= c && c <= 0x2ffff)) {
+            numBytes += 3;
+        } else {
+            numBytes += 4;
+        }
+    }
+    return numBytes;
+}
+
+static int32_t
+encodeLength(int32_t length) {
+    /* variable-length encoding of the length field */
+    uint8_t bytes[5];
+    --length;  /* empty strings use the mini format */
+    if (length <= 0x3d) {
+        bytes[0] = (uint8_t)length;
+        return 1;
+    } else if (length <= 0xff) {
+        bytes[0] = (uint8_t)(0x3e | (length >> 7));
+        bytes[1] = (uint8_t)(length & 0x7f);
+        return 2;
+    } else if (length <= 0x7fff) {
+        bytes[0] = (uint8_t)(0x3e | (length >> 14));
+        bytes[1] = (uint8_t)((length >> 7) | 0x80);
+        bytes[2] = (uint8_t)(length & 0x7f);
+        return 3;
+    } else if (length <= 0x3fffff) {
+        bytes[0] = (uint8_t)(0x3e | (length >> 21));
+        bytes[1] = (uint8_t)((length >> 14) | 0x80);
+        bytes[2] = (uint8_t)((length >> 7) | 0x80);
+        bytes[3] = (uint8_t)(length & 0x7f);
+        return 4;
+    } else /* .res format limits strings to fewer than 1<<29 UChars */ {
+        bytes[0] = (uint8_t)(0x3e | (length >> 28));
+        bytes[1] = (uint8_t)((length >> 21) | 0x80);
+        bytes[2] = (uint8_t)((length >> 14) | 0x80);
+        bytes[3] = (uint8_t)((length >> 7) | 0x80);
+        bytes[3] = (uint8_t)(length & 0x7f);
+        return 5;
+    }
+}
+
+static int32_t getPotentialSize(const struct SRBRoot *bundle, const UChar *s, int32_t length) {
+    int32_t fewestBytes = 0x7fffffff, bestWindow = -1;
+    int32_t i;
+
+    /*
+     * Possible code optimizations:
+     * - pass fewestBytes into encoders so that they can stop
+     *   when they exceed it
+     *   + initialize it with the number of UTF-16 bytes
+     *     // choose UTF-16 if that's the shortest
+     *     fewestBytes = 4 + 2 * (length + 1) + calcPadding(length * 2)
+     * - get the set of used windows from the decoders so we can skip
+     *   trying the other windows if they are unused
+     * - have single-byte encoder check for is2ByteCJK() so we can skip
+     *   the CJK encoder if no such characters occur
+     * - have single-byte encoder detect when it uses exactly one byte
+     *   per code point, and stop here in that case
+     */
+    int32_t lengthBytes = encodeLength(length);
+    for (i = 0; i <= 3; ++i) {
+        int32_t numBytes = lengthBytes;
+        if (i <= 2) {
+            numBytes += encodeSingleByteMode(bundle, bundle->fWindows[i], s, length);
+        } else {
+            numBytes += encodeCJK(bundle, s, length);
+        }
+        if (numBytes < fewestBytes) {
+            fewestBytes = numBytes;
+            bestWindow = i;
+        }
+    }
+    return fewestBytes;
+}
+
+/* call this after the top windows are set TODO: remove */
+static void
+addToStatsWithWindows(const struct SRBRoot *bundle, const UChar *s, int32_t length) {
+    const int32_t *windows = bundle->fWindows;
+    int32_t i, windowIndex;
+    UChar32 c;
+
+    for (i = 0; i < length;) {
+        c = s[i++];  /* don't care about supplementary characters here */
+        if (isCompressible(c) && !isDirectASCII(c) &&
+            getWindow(windows, c, &windowIndex) < 0
+        ) {
+            printf("other-char: %04lx\n", (long)c);
+        }
+    }
+}
+
 /*
  * res_none() returns the address of kNoResource,
  * for use in non-error cases when no resource is to be added to the bundle.
@@ -34,7 +344,7 @@
  */
 static struct SResource kNoResource = { RES_NONE };
 
-uint32_t res_write(UNewDataMemory *mem, struct SResource *res,
+uint32_t res_write(UNewDataMemory *mem, struct SRBRoot *bundle, struct SResource *res,
                    uint32_t usedOffset, UErrorCode *status);
 
 static const UDataInfo dataInfo= {
@@ -66,18 +376,45 @@
 }
 
 /* Writing Functions */
-static uint32_t string_write(UNewDataMemory *mem, struct SResource *res,
+static uint32_t string_write(UNewDataMemory *mem, struct SRBRoot *bundle, struct SResource *res,
                              uint32_t usedOffset, UErrorCode *status) {
-    udata_write32(mem, res->u.fString.fLength);
-    udata_writeUString(mem, res->u.fString.fChars, res->u.fString.fLength + 1);
-    udata_writePadding(mem, calcPadding(res->fSize));
+    const UChar *s = res->u.fString.fChars;
+    int32_t length = res->u.fString.fLength;
+    int32_t normalSize;
+    uint8_t paddingSize = calcPadding(res->fSize);
+    udata_write32(mem, length);
+    udata_writeUString(mem, s, length + 1);
+    udata_writePadding(mem, paddingSize);
 
+    ++bundle->fStringsCount;
+    normalSize = 4 /* res. item */ + res->fSize + paddingSize;
+    bundle->fStringsSize += normalSize;
+    if (encodeMiniString(bundle, s, length) != 0xffffffff) {
+        bundle->fPotentialSize += 4;  /* all in the resource item */
+        ++bundle->f4ASCIICount;
+        bundle->f4ASCIIReduction += normalSize - 4;
+    } else {
+        int32_t potentialSize = getPotentialSize(bundle, s, length);
+        potentialSize += 4 /* resource item */;
+        if (potentialSize < normalSize) {
+            /* use the compressed form */
+            bundle->fPotentialSize += potentialSize;
+        } else {
+            /* use the standard UTF-16 form */
+            bundle->fPotentialSize += normalSize;
+            ++bundle->fIncompressibleStrings;
+            printf("incompressible: length %ld  normalSize %ld  potentialSize %ld\n",
+                   (long)length, (long)normalSize, (long)potentialSize);
+        }
+        /*addToStatsWithWindows(bundle, s, length);*/
+    }
+
     return usedOffset;
 }
 
 /* Writing Functions */
-static uint32_t alias_write(UNewDataMemory *mem, struct SResource *res,
-                             uint32_t usedOffset, UErrorCode *status) {
+static uint32_t alias_write(UNewDataMemory *mem, struct SRBRoot *bundle, struct SResource *res,
+                            uint32_t usedOffset, UErrorCode *status) {
     udata_write32(mem, res->u.fString.fLength);
     udata_writeUString(mem, res->u.fString.fChars, res->u.fString.fLength + 1);
     udata_writePadding(mem, calcPadding(res->fSize));
@@ -85,7 +422,7 @@
     return usedOffset;
 }
 
-static uint32_t array_write(UNewDataMemory *mem, struct SResource *res,
+static uint32_t array_write(UNewDataMemory *mem, struct SRBRoot *bundle, struct SResource *res,
                             uint32_t usedOffset, UErrorCode *status) {
     uint32_t *resources = NULL;
     uint32_t  i         = 0;
@@ -113,11 +450,11 @@
             } else if (current->fType == URES_BINARY) {
                 uint32_t uo = usedOffset;
 
-                usedOffset    = res_write(mem, current, usedOffset, status);
+                usedOffset    = res_write(mem, bundle, current, usedOffset, status);
                 resources[i]  = (current->fType << 28) | (usedOffset >> 2);
                 usedOffset   += current->fSize + calcPadding(current->fSize) - (usedOffset - uo);
             } else {
-                usedOffset    = res_write(mem, current, usedOffset, status);
+                usedOffset    = res_write(mem, bundle, current, usedOffset, status);
                 resources[i]  = (current->fType << 28) | (usedOffset >> 2);
                 usedOffset   += current->fSize + calcPadding(current->fSize);
             }
@@ -139,7 +476,7 @@
     return usedOffset;
 }
 
-static uint32_t intvector_write(UNewDataMemory *mem, struct SResource *res,
+static uint32_t intvector_write(UNewDataMemory *mem, struct SRBRoot *bundle, struct SResource *res,
                                 uint32_t usedOffset, UErrorCode *status) {
   uint32_t i = 0;
     udata_write32(mem, res->u.fIntVector.fCount);
@@ -150,7 +487,7 @@
     return usedOffset;
 }
 
-static uint32_t bin_write(UNewDataMemory *mem, struct SResource *res,
+static uint32_t bin_write(UNewDataMemory *mem, struct SRBRoot *bundle, struct SResource *res,
                           uint32_t usedOffset, UErrorCode *status) {
     uint32_t pad       = 0;
     uint32_t extrapad  = calcPadding(res->fSize);
@@ -171,12 +508,12 @@
     return usedOffset;
 }
 
-static uint32_t int_write(UNewDataMemory *mem, struct SResource *res,
+static uint32_t int_write(UNewDataMemory *mem, struct SRBRoot *bundle, struct SResource *res,
                           uint32_t usedOffset, UErrorCode *status) {
     return usedOffset;
 }
 
-static uint32_t table_write(UNewDataMemory *mem, struct SResource *res,
+static uint32_t table_write(UNewDataMemory *mem, struct SRBRoot *bundle, struct SResource *res,
                             uint32_t usedOffset, UErrorCode *status) {
     uint8_t   pad       = 0;
     uint32_t  i         = 0;
@@ -234,11 +571,11 @@
             } else if (current->fType == URES_BINARY) {
                 uint32_t uo = usedOffset;
 
-                usedOffset    = res_write(mem, current, usedOffset, status);
+                usedOffset    = res_write(mem, bundle, current, usedOffset, status);
                 resources[i]  = (current->fType << 28) | (usedOffset >> 2);
                 usedOffset   += current->fSize + calcPadding(current->fSize) - (usedOffset - uo);
             } else {
-                usedOffset    = res_write(mem, current, usedOffset, status);
+                usedOffset    = res_write(mem, bundle, current, usedOffset, status);
                 resources[i]  = (current->fType << 28) | (usedOffset >> 2);
                 usedOffset   += current->fSize + calcPadding(current->fSize);
             }
@@ -276,7 +613,7 @@
     return usedOffset;
 }
 
-uint32_t res_write(UNewDataMemory *mem, struct SResource *res,
+uint32_t res_write(UNewDataMemory *mem, struct SRBRoot *bundle, struct SResource *res,
                    uint32_t usedOffset, UErrorCode *status) {
     if (U_FAILURE(*status)) {
         return 0;
@@ -285,20 +622,20 @@
     if (res != NULL) {
         switch (res->fType) {
         case URES_STRING:
-            return string_write    (mem, res, usedOffset, status);
+            return string_write    (mem, bundle, res, usedOffset, status);
         case URES_ALIAS:
-            return alias_write    (mem, res, usedOffset, status);
+            return alias_write     (mem, bundle, res, usedOffset, status);
         case URES_INT_VECTOR:
-            return intvector_write (mem, res, usedOffset, status);
+            return intvector_write (mem, bundle, res, usedOffset, status);
         case URES_BINARY:
-            return bin_write       (mem, res, usedOffset, status);
+            return bin_write       (mem, bundle, res, usedOffset, status);
         case URES_INT:
-            return int_write       (mem, res, usedOffset, status);
+            return int_write       (mem, bundle, res, usedOffset, status);
         case URES_ARRAY:
-            return array_write     (mem, res, usedOffset, status);
+            return array_write     (mem, bundle, res, usedOffset, status);
         case URES_TABLE:
         case URES_TABLE32:
-            return table_write     (mem, res, usedOffset, status);
+            return table_write     (mem, bundle, res, usedOffset, status);
 
         default:
             break;
@@ -326,6 +663,8 @@
         return;
     }
 
+    findTopWindows(bundle);
+
     if (writtenFilename) {
        int32_t off = 0, len = 0;
        if (outputDir) {
@@ -423,18 +762,39 @@
     udata_writeBlock(mem, bundle->fKeys+URES_STRINGS_BOTTOM,
                           bundle->fKeyPoint-URES_STRINGS_BOTTOM);
 
+    {
+        const char *keysStart = bundle->fKeys+URES_STRINGS_BOTTOM;
+        const char *keysLimit = keysStart + bundle->fKeyPoint-URES_STRINGS_BOTTOM;
+        const char *keys = keysStart;
+        while (keys < keysLimit) {
+            char c = *keys;
+            if (c != 0 && !('a' <= c && c <= 'z') && !('A' <= c && c <= 'Z') && !('0' <= c && c <= '9')) {
+                printf("other-key: %02x\n", (int)c);
+                if (keys == keysStart || *(keys - 1) == 0) {
+                    printf("initial-key: %02x\n", (int)c);
+                }
+            }
+            ++keys;
+        }
+    }
+
     /* write the padding bytes after the table key strings */
     udata_writePadding(mem, pad);
 
     /* write all of the bundle contents: the root item and its children */
-    usedOffset = res_write(mem, bundle->fRoot, usedOffset, status);
+    usedOffset = res_write(mem, bundle, bundle->fRoot, usedOffset, status);
 
+    /* TODO: in real code, this has to happen after the compressed-string-writing phase and before the next phase */
+    bundle->fCompressedPadding = calcPadding(bundle->fPotentialSize);
+
     size = udata_finish(mem, status);
     if(top != size) {
         fprintf(stderr, "genrb error: wrote %u bytes but counted %u\n",
                 (int)size, (int)top);
         *status = U_INTERNAL_PROGRAM_ERROR;
     }
+
+    printCounters(bundle, writtenFilename, size);
 }
 
 /* Opening Functions */
@@ -549,6 +909,8 @@
     uprv_memcpy(res->u.fString.fChars, value, sizeof(UChar) * (len + 1));
     res->fSize = sizeof(int32_t) + sizeof(UChar) * (len+1);
 
+    addToStats(bundle, value, len);
+
     return res;
 }
 
Index: source/tools/genrb/reslist.h
===================================================================
--- source/tools/genrb/reslist.h	(revision 25919)
+++ source/tools/genrb/reslist.h	(working copy)
@@ -32,6 +32,9 @@
 
 U_CDECL_BEGIN
 
+/* experimental compression */
+#define LAST_WINDOW_LIMIT 0x20000
+
 /* Resource bundle root table */
 struct SRBRoot {
   char *fLocale;
@@ -42,6 +45,14 @@
   struct SResource *fRoot;
   int32_t fMaxTableLength;
   UBool noFallback; /* see URES_ATT_NO_FALLBACK */
+
+  /* experimental compression */
+  int32_t fStringsCount, fStringsSize;
+  int32_t fPotentialSize, f4ASCIICount, f4ASCIIReduction;
+  int32_t fIncompressibleStrings;
+  int32_t fCompressedPadding;
+  int32_t fWindowCounts[LAST_WINDOW_LIMIT>>7];
+  int32_t fWindows[3];
 };
 
 struct SRBRoot *bundle_open(const struct UString* comment, UErrorCode *status);
Index: source/tools/genrb/genrb.c
===================================================================
--- source/tools/genrb/genrb.c	(revision 25919)
+++ source/tools/genrb/genrb.c	(working copy)
@@ -254,7 +254,7 @@
         }
         uprv_strcat(theCurrentFileName, arg);
 
-        if (isVerbose()) {
+        if (1||                  isVerbose()) {
             printf("Processing file \"%s\"\n", theCurrentFileName);
         }
         processFile(arg, encoding, inputDir, outputDir, gPackageName, &status);
